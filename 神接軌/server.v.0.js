// Generated by CoffeeScript 1.7.1
(function() {
  var app, db, extensions, findUserByMap, fs, handler, io, mongodb, mongodbServer, path, readFile, removeUser, responseWrite, userTimeout, users, zlib;

  app = require('http').createServer(handler);

  io = require('socket.io').listen(app);

  mongodb = require('mongodb');

  path = require('path');

  fs = require('fs');

  zlib = require('zlib');

  extensions = {
    ".html": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
    ".png": "image/png",
    ".gif": "image/gif",
    ".jpg": "image/jpeg"
  };

  app.listen(81);

  handler = function(req, res) {
    var ext, filename, mimeType;
    if (req.url != null) {
      filename = req.url;
    } else {
      filename = "game_sample.html";
    }
    if (filename === "/") {
      filename = "/game_sample.html";
    }
    ext = path.extname(filename);
    mimeType = extensions[ext];
    return fs.stat(__dirname + filename, function(err, stat) {
      var expires, header, lastModified, maxAge;
      if (err) {
        return responseWrite(res, 404, {
          'Content-Type': 'text/plain'
        }, 'This request URL ' + req.url + ' was not found on this server.');
      } else if (stat.isDirectory()) {
        return responseWrite(res, 500, err);
      } else {
        header = {
          'Content-Type': mimeType || 'text/plain'
        };
        if (ext.slice(1).match(/^(gif|png|jpg|css)$/ig)) {
          expires = new Date();
          maxAge = 60 * 60 * 24 * 30;
          expires.setTime(expires.getTime() + maxAge * 1000);
          header['Expires'] = expires.toUTCString();
          header['Cache-Control'] = 'max-age=' + maxAge;
          fs.stat(__dirname + filename, function(err, stat) {});
          lastModified = stat.mtime.toUTCString();
          header['Last-Modified'] = lastModified;
          if (req.headers['if-modified-since'] && lastModified === req.headers['if-modified-since']) {
            return responseWrite(res, 304, 'Not Modified');
          } else {
            return readFile(req, res, __dirname + filename, header, ext.slice(1));
          }
        } else {
          return readFile(req, res, __dirname + filename, header, ext.slice(1));
        }
      }
    });
  };

  readFile = function(req, res, realPath, header, type) {
    var cFun, raw;
    raw = fs.createReadStream(realPath);
    cFun = null;
    if (type.match(/css|js|html/ig) && req.headers['accept-encoding']) {
      if (req.headers['accept-encoding'].match(/\bgzip\b/)) {
        header['Content-Encoding'] = 'gzip';
        cFun = 'createGzip';
      } else if (req.headers['accept-encoding'].match(/\bdeflate\b/)) {
        header['Content-Encoding'] = 'deflate';
        cFun = 'createDeflate';
      }
    }
    res.writeHead(200, header);
    if (cFun) {
      return raw.pipe(zlib[cFun]()).pipe(res);
    } else {
      return raw.pipe(res);
    }
  };

  responseWrite = function(res, starus, header, output, encoding) {
    encoding = encoding || 'utf8';
    res.writeHead(starus, header);
    if (output) {
      res.write(output, encoding);
    }
    return res.end();
  };

  users = [];

  mongodbServer = new mongodb.Server('localhost', 27017, {
    auto_reconnect: true,
    poolSize: 10
  });

  db = new mongodb.Db('mydb', mongodbServer, {
    w: 1
  });

  io.set('log level', 1);

  io.on('connection', function(socket) {
    socket.on('login', function(data) {
      return db.open(function() {
        return db.collection('users', function(err, collection) {
          var re;
          re = "";
          return collection.findOne({
            username: data.username,
            password: data.password
          }, function(err, user) {
            if (user) {
              re = "success";
            } else {
              re = "error";
            }
            socket.emit('LoginResponse', {
              request: re,
              user: user
            });
            return db.close();
          });
        });
      });
    });
    socket.on('Users', function(data) {
      var idx, users_by_map;
      idx = users.map(function(ele) {
        return JSON.parse(ele.user).name;
      }).indexOf(JSON.parse(data.user).name);
      if (idx === -1) {
        users.push({
          user: data.user,
          lastTime: data.lastTime
        });
      } else {
        users[idx].user = data.user;
        users[idx].lastTime = data.lastTime;
      }
      users_by_map = findUserByMap(JSON.parse(data.user).map);
      return socket.emit('UsersByMapResponse', {
        users: users_by_map
      });
    });
    return socket.on('SignUp', function(data) {
      return db.open(function() {
        return db.collection('users', function(err, collection) {
          var re;
          re = "";
          return collection.insert({
            name: data.name,
            username: data.username,
            password: data.password,
            job: data.job,
            position: [22, 9],
            map: "rock"
          }, function(err, user) {
            if (user) {
              socket.emit("SignUpResponse", {
                request: "success",
                user: user
              });
            } else {
              socket.emit("SignUpResponse", {
                request: "error",
                reason: err
              });
            }
            return db.close();
          });
        });
      });
    });
  });

  io.sockets.on('connection', function(socket) {
    return socket.on('ReceiveChat', function(data) {
      var tim;
      tim = new Date();
      return io.sockets.emit('Chat', {
        time: tim.getHours() + ":" + tim.getMinutes(),
        name: data.name,
        msg: data.msg
      });
    });
  });

  findUserByMap = function(mapname) {
    var user, users_by_map, _i, _len, _ref;
    users_by_map = [];
    _ref = users.length;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      user = _ref[_i];
      if (JSON.parse(user.user).map === mapname) {
        users_by_map.push(user);
      }
    }
    return users_by_map;
  };

  setInterval(userTimeout, 3000);

  userTimeout = function() {
    var tim;
    tim = new Date();
    return users.map(function(ele) {
      if ((tim.getTime() - ele.lastTime) > (1000 * 5)) {
        return removeUser(JSON.parse(ele.user).id);
      }
    });
  };

  removeUser = function(user_id) {
    var idx;
    idx = users.map(function(ele) {
      return JSON.parse(ele.user).id;
    }).indexOf(user_id);
    if (idx !== -1) {
      return users.splice(idx, 1);
    }
  };

}).call(this);
