// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Animate = (function(_super) {
    __extends(Animate, _super);

    function Animate(name, sprite, id) {
      this.name = name;
      this.sprite = sprite;
      this.id = id;
      this.position = [0, 0];
      this.action_index = 0;
      this.offset = [0, 0];
      this.moment = 0;
      this.dir = 0;
      this.path = [0];
      this.walk_timer = 0;
      this.target = [0, 0];
      this.lv = 1;
      this.healTimeout = this.interval(this.recover, 1000);
      this.interval(this.calculate, 1000);
      this.attackDelaying = 0;
      this.action = 3;
      this.talking = 0;
      this.dieing = 0;
      this.walking = 0;
      this.skillCD = [];
      this.statusList = [];
      this.realFlee = 100;
      this.flee = 100;
      this.realHit = 80;
      this.hit = 80;
      this.realSpeed = 400;
      this.speed = 400;
      this.realMaxHP = 100;
      this.maxHP = 100;
      this.hp = 100;
      this.realRecoverHP = 1;
      this.recoverHP = 0;
      this.realMaxMP = 100;
      this.maxMP = 100;
      this.mp = 100;
      this.realRecoverMP = 100;
      this.recoverMP = 0;
      this.realAtk = 10;
      this.atk = 0;
      this.realAspd = 300;
      this.aspd = 300;
      this.exp = 100;
      this.nextLvNeedExp = 100;
      this.realDef = 1;
      this.def = 0;
    }

    Animate.prototype.action_clear = function() {
      this.offset = [0, 0];
      clearTimeout(this.walkTimeout);
      clearTimeout(this.subWalkTimeout);
      clearTimeout(this.attackTimeout);
      clearTimeout(this.damageTimeout);
      clearTimeout(this.clearActimeTimeout);
      this.moving = 0;
      this.action = 3;
    };

    Animate.prototype.die = function() {
      this.dieing = 1;
      this.action = 0;
      return this.timeout(this.died, 1000);
    };

    Animate.prototype.died = function() {
      return this.map.monster.splice(this.map.monster.indexOf(this), 1);
    };

    Animate.prototype.damage = function(attack_target, damage) {
      var dir, i, o, _i, _len, _ref;
      if (attack_target.hit / this.flee < Math.random()) {
        game.text.showText("miss", "#FF0000", attack_target.map, attack_target.position[0], attack_target.position[1], [0, 0], [0, -2], 30);
        return;
      }
      this.action_clear();
      this.action = 4;
      this.moment = 0;
      dir = this.dir % this.sprite.rect[this.action].length;
      this.timeout(this.action_clear, this.sprite.rect[this.action][dir].length * this.aspd);
      damage -= random(Math.floor(this.def / 2), this.def);
      if (this.statusList != null) {
        _ref = this.statusList;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          o = _ref[i];
          if (o[0].id === 8) {
            if (o[3] > random(1, 20)) {
              attack_target.damage(this, damage);
              return;
            }
          }
        }
      }
      if (damage < 1) {
        damage = 1;
      }
      this.hp -= damage;
      if (this === game.role) {
        game.text.showDamage(damage, this.map, this.position[0], this.position[1], "#FF0000");
      } else {
        game.text.showDamage(damage, this.map, this.position[0], this.position[1], "#FFFFFF");
      }
      this.attack_target = attack_target;
      if (this.hp < 0 && this.dieing === 0) {
        this.die();
      }
      return this.damage_sub();
    };

    Animate.prototype.damage_sub = function() {
      var dir;
      dir = this.dir % this.sprite.rect[this.action].length;
      this.moment = ++this.moment % this.sprite.rect[this.action][dir].length;
      return this.damageTimeout = this.timeout(this.damage_sub, this.aspd);
    };

    Animate.prototype.useSkill = function() {
      var dir;
      if (!this.hp) {
        return 2;
      }
      if (this.moving) {
        return 3;
      }
      if (this.attackDelaying) {
        return 4;
      }
      this.action_clear();
      this.action = 2;
      this.moment = 0;
      this.attackDelaying = 1;
      dir = this.dir % this.sprite.rect[this.action].length;
      this.timeout(this.after_attack, this.sprite.rect[this.action][dir].length * this.aspd);
      this.clearActimeTimeout = this.timeout(this.action_clear, this.sprite.rect[this.action][dir].length * this.aspd);
      this.attack_sub();
    };

    Animate.prototype.attack = function(target) {
      var dir;
      if (!this.hp) {
        return 2;
      }
      if (this.moving) {
        return 3;
      }
      if (this.attackDelaying) {
        return 4;
      }
      this.action_clear();
      this.action = 2;
      this.moment = 0;
      this.attackDelaying = 1;
      dir = this.dir % this.sprite.rect[this.action].length;
      this.timeout(this.after_attack, this.sprite.rect[this.action][dir].length * this.aspd);
      this.clearActimeTimeout = this.timeout(this.action_clear, this.sprite.rect[this.action][dir].length * this.aspd);
      this.attack_sub();
    };

    Animate.prototype.after_attack = function() {
      return this.attackDelaying = 0;
    };

    Animate.prototype.attack_sub = function() {
      var dir;
      dir = this.dir % this.sprite.rect[this.action].length;
      this.moment = ++this.moment % this.sprite.rect[this.action][dir].length;
      this.attackTimeout = this.timeout(this.attack_sub, this.aspd);
    };

    Animate.prototype.moveTo = function(x, y) {
      var dx, dy, path;
      if (this.action !== 3 && this.action !== 5) {
        return;
      }
      if (!this.hp) {
        return;
      }
      this.action = 5;
      if (!this.moving) {
        dy = Math.sign(y - this.position[1]);
        dx = Math.sign(x - this.position[0]);
        this.dir = sign2dir(dx, dy);
      }
      if ((game.role.map.git[y] == null) || (game.role.map.git[y][x] == null)) {
        return;
      }
      if (game.role.map.git[y][x] === 0) {
        return;
      }
      if (this.target[0] === x && this.target[1] === y) {
        return;
      }
      this.target = [x, y];
      this.path = path = this.map.search_path(this.position[0], this.position[1], x, y);
      if (this.path.length === 0) {
        return;
      }
      if (!this.moving) {
        return this.start_move();
      }
    };

    Animate.prototype.start_move = function() {
      this.move();
      this.walk();
      this.action = 5;
    };

    Animate.prototype.move = function() {
      var sign;
      this.moment = 0;
      this.moving = 1;
      if (this.path.length === 0) {
        this.action_clear();
        return;
      }
      this.dir = this.path[0];
      sign = dir2sign(this.dir);
      this.position[0] += sign[0];
      this.position[1] += sign[1];
      this.offset[0] = -1 * sign[0] * game.gridSize;
      this.offset[1] = -1 * sign[1] * game.gridSize;
      this.path.shift();
      return this.walkTimeout = this.timeout(this.move, this.speed);
    };

    Animate.prototype.walk = function() {
      var dir, sign;
      dir = this.dir % this.sprite.rect[this.action].length;
      this.moment = ++this.moment % this.sprite.rect[this.action][dir].length;
      sign = dir2sign(this.dir);
      this.offset[0] += sign[0] * game.gridSize / this.sprite.rect[this.action][dir].length;
      this.offset[1] += sign[1] * game.gridSize / this.sprite.rect[this.action][dir].length;
      this.subWalkTimeout = this.timeout(this.walk, this.speed / this.sprite.rect[this.action][dir].length);
    };

    Animate.prototype.wrapTo = function(x, y) {
      this.position = [x, y];
    };

    Animate.prototype.redraw = function() {
      this.sprite.draw(this.position[0], this.position[1], this.action, this.dir, this.moment, this.offset);
      this.drawHp();
      return this.drawName();
    };

    Animate.prototype.drawHp = function() {
      var context, position;
      if (this.hp >= 0) {
        position = getRealPosition(this.position[0], this.position[1], this.offset);
        context = game.canvas.context;
        context.fillStyle = 'black';
        context.fillRect(position[0] - 1, position[1] + game.gridSize - 1, game.gridSize + 2, 7);
        context.fillStyle = 'green';
        if ((this.hp / this.maxHP) < 0.1) {
          context.fillStyle = 'red';
        }
        return context.fillRect(position[0], position[1] + game.gridSize, game.gridSize * (this.hp / this.maxHP), 5);
      }
    };

    Animate.prototype.drawName = function() {
      var context, name_length, position;
      position = getRealPosition(this.position[0], this.position[1], this.offset);
      context = game.canvas.context;
      context.font = "12px Arial";
      name_length = this.name.length;
      name_length *= 12;
      name_length /= 2;
      context.fillStyle = "black";
      context.textAlign = "center";
      context.fillText(this.name, position[0] + (game.gridSize / 2), position[1] + game.gridSize + 18 + 1);
      context.fillText(this.name, position[0] + (game.gridSize / 2), position[1] + game.gridSize + 18 - 1);
      context.fillText(this.name, position[0] + (game.gridSize / 2) - 1, position[1] + game.gridSize + 18);
      context.fillText(this.name, position[0] + (game.gridSize / 2) + 1, position[1] + game.gridSize + 18);
      context.fillStyle = "white";
      return context.fillText(this.name, position[0] + (game.gridSize / 2), position[1] + game.gridSize + 18);
    };

    Animate.prototype.heal = function(hp, mp) {
      if (mp == null) {
        mp = 0;
      }
      if (hp) {
        this.hp += hp;
        if (this.hp > this.maxHP) {
          this.hp = this.maxHP;
        }
        game.text.showText(hp, "#01814A", this.map, this.position[0], this.position[1], [0, 0], [0, -2], 30);
      }
      if (mp) {
        this.mp += mp;
        if (this.mp > this.maxMP) {
          this.mp = this.maxMP;
        }
        game.text.showText(mp, "#8600FF", this.map, this.position[0], this.position[1], [0, 20], [0, -2], 30);
      }
    };

    Animate.prototype.recover = function() {
      if (this.hp !== -1) {
        this.hp += this.recoverHP;
        if (this.hp > this.maxHP) {
          this.hp = this.maxHP;
        }
      }
      this.mp += this.recoverMP;
      if (this.mp > this.maxMP) {
        return this.mp = this.maxMP;
      }
    };

    Animate.prototype.calculate = function() {
      var deleteList, i, o, _i, _j, _len, _len1, _ref, _results;
      this.speed = this.realSpeed;
      this.atk = this.realAtk;
      this.aspd = this.realAspd;
      this.maxHP = this.realMaxHP;
      this.maxMP = this.realMaxMP;
      this.recoverHP = this.realRecoverHP;
      this.recoverMP = this.realRecoverMP;
      this.hit = this.realHit;
      this.flee = this.realFlee;
      this.def = this.realDef;
      deleteList = [];
      if (this.statusList != null) {
        _ref = this.statusList;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          o = _ref[i];
          o[0].fn(this, o[3]);
          if (new Date().getTime() - o[2] > o[1]) {
            deleteList.push(i);
          }
        }
      }
      _results = [];
      for (_j = 0, _len1 = deleteList.length; _j < _len1; _j++) {
        i = deleteList[_j];
        _results.push(this.statusList.splice(i, 1));
      }
      return _results;
    };

    return Animate;

  })(window.Base);

}).call(this);
