// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Map = (function(_super) {
    __extends(Map, _super);

    function Map(name, width, height, data, git, objects, palettes, _objects) {
      var i, o, palette, _i, _j, _len, _len1;
      this.name = name;
      this.width = width;
      this.height = height;
      this.data = data;
      this.git = git;
      this.objects = objects;
      this.key = this.name;
      game.maps.add(this);
      this.palette = [];
      this.monster_list = [["瘋兔", monster.m001, 50, 5], ["魔菇", monster.m002, 50, 5], ["食人花", monster.m003, 50, 5], ["狼", monster.m004, 50, 5], ["大腳熊", monster.m005, 50, 5], ["獸人戰士", monster.m006, 50, 5], ["巨石兵", monster.m007, 50, 5], ["天使波利", monster.m008, 50, 5], ["褐色方塊體", monster.m009, 50, 5], ["巴風特", monster.m010, 668000, 2864], ["波利", monster.m011, 50, 5], ["藍兔", monster.m012, 65, 70], ["蒼鷹男爵", monster.m013, 21000, 450], ["赤焰小惡魔", monster.m014, 10579, 544], ["獸人腐屍", monster.m015, 1908, 109], ["獸人英雄", monster.m016, 80000, 1000], ["蒼蠅", monster.m020, 57, 11], ["青蛇", monster.m021, 217, 23], ["磨卡", monster.m022, 468, 66], ["蠍子", monster.m023, 150, 33], ["女僕", monster.m024, 920, 390], ["毒蛇", monster.m025, 8500, 380], ["嗜血怪人", monster.m026, 14000, 800]];
      this.monster = [];
      this.npc = [];
      for (i = _i = 0, _len = palettes.length; _i < _len; i = ++_i) {
        palette = palettes[i];
        this.palette[i] = game.sprites.add(new Sprite(palette));
      }
      this.object = [];
      for (i = _j = 0, _len1 = _objects.length; _j < _len1; i = ++_j) {
        o = _objects[i];
        this.object[i] = game.sprites.add(new Sprite(o));
      }
    }

    Map.prototype.redraw = function() {
      var centerPosition, h, i, object, w, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4;
      centerPosition = game.role.position;
      for (w = _i = _ref = centerPosition[0] - game.viewRange[0] - 1, _ref1 = centerPosition[0] + game.viewRange[0] + 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; w = _ref <= _ref1 ? ++_i : --_i) {
        for (h = _j = _ref2 = centerPosition[1] - game.viewRange[1] - 1, _ref3 = centerPosition[1] + game.viewRange[1] + 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; h = _ref2 <= _ref3 ? ++_j : --_j) {
          if (w < 0 || w >= this.data.length - 1 || h < 0 || h >= this.data[w].length - 1 || this.data[w][h] === 0) {
            continue;
          }
          if (this.data[h][w] <= 0) {
            this.data[h][w] = 1;
          }
          this.palette[this.data[h][w] - 1].draw(w, h);
        }
      }
      _ref4 = this.objects;
      for (i = _k = 0, _len = _ref4.length; _k < _len; i = ++_k) {
        object = _ref4[i];
        this.object[object[2] - 1].realDraw(object[0], object[1]);
      }
    };

    Map.prototype.drawFrontObject = function() {
      var i, object, _i, _len, _ref;
      _ref = this.objects;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        object = _ref[i];
        if (object[1] + this.object[object[2] - 1].dom.height - 80 > game.role.position[1] * 40) {
          this.object[object[2] - 1].realDraw(object[0], object[1]);
        }
      }
    };

    Map.prototype.findNpc = function(x, y) {
      var npc, _i, _len, _ref;
      _ref = this.npc;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        npc = _ref[_i];
        if (npc.position[0] === x && npc.position[1] === y) {
          return npc;
        }
      }
      return null;
    };

    Map.prototype.touchNPC = function(x, y) {
      var npc, _i, _len, _ref;
      _ref = this.npc;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        npc = _ref[_i];
        if (npc.position[0] + npc.range_x >= x && npc.position[0] - npc.range_x <= x && npc.position[1] + npc.range_y >= y && npc.position[1] - npc.range_y <= y) {
          return npc;
        }
      }
      return null;
    };

    Map.prototype.findMonster = function(x, y) {
      var monster, _i, _len, _ref;
      _ref = this.monster;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        monster = _ref[_i];
        if (monster.position[0] === x && monster.position[1] === y) {
          return monster;
        }
      }
      return null;
    };

    Map.prototype.findPath = function() {
      var c, path, r, x, y, _i, _j, _len, _len1, _ref;
      path = [];
      _ref = this.git;
      for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
        r = _ref[y];
        for (x = _j = 0, _len1 = r.length; _j < _len1; x = ++_j) {
          c = r[x];
          if (c === 1) {
            path.push([x, y]);
          }
        }
      }
      return path;
    };

    Map.prototype.search_path = function(x, y, to_x, to_y) {
      var dx, dy, end, graph, i, j, node, path, path_choicse, result, start, _git, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _x, _y;
      path_choicse = [[3, 4, 5], [2, 0, 6], [1, 0, 7]];
      path = [];
      _git = [];
      _ref = this.git[0];
      for (_y = _i = 0, _len = _ref.length; _i < _len; _y = ++_i) {
        i = _ref[_y];
        _git[_y] = [];
      }
      _ref1 = this.git;
      for (_x = _j = 0, _len1 = _ref1.length; _j < _len1; _x = ++_j) {
        i = _ref1[_x];
        _ref2 = this.git[x];
        for (_y = _k = 0, _len2 = _ref2.length; _k < _len2; _y = ++_k) {
          j = _ref2[_y];
          _git[_y][_x] = this.git[_x][_y];
        }
      }
      graph = new Graph(_git);
      if ((graph.nodes[x][y] == null) || (graph.nodes[to_x] == null) || (graph.nodes[to_x][to_y] == null)) {
        return;
      }
      start = graph.nodes[x][y];
      end = graph.nodes[to_x][to_y];
      result = astar.search(graph.nodes, start, end);
      for (_l = 0, _len3 = result.length; _l < _len3; _l++) {
        node = result[_l];
        dx = Math.sign(node.x - x);
        dy = Math.sign(node.y - y);
        x = node.x;
        y = node.y;
        path.push(path_choicse[dy + 1][dx + 1]);
      }
      return path;
    };

    Map.prototype.createMonster = function(time) {
      var local, path;
      path = this.findPath();
      local = path[random(0, path.length)];
      if (time == null) {
        time = 6000;
      }
      return this.timeout(function() {
        var blue_water, monster, monster_idx, red_water;
        monster_idx = random(0, this.monster_list.length);
        monster = new Monster(this.monster_list[monster_idx][0], this.monster_list[monster_idx][1], this.name, local[0], local[1]);
        monster.realMaxHP = this.monster_list[monster_idx][2];
        monster.maxHP = this.monster_list[monster_idx][2];
        monster.hp = this.monster_list[monster_idx][2];
        monster.exe = monster.hp / 2;
        monster.realAtk = this.monster_list[monster_idx][3];
        monster.atk = this.monster_list[monster_idx][3];
        red_water = new RedWater;
        blue_water = new BlueWater;
        monster.addGife(red_water);
        return monster.addGife(blue_water);
      }, time);
    };

    return Map;

  })(window.Base);

}).call(this);
