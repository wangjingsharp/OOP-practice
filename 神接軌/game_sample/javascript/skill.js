// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.HotkeyManager = (function() {
    function HotkeyManager() {
      this.data = [];
      this.win = new Windows(100, 200, '快捷鍵設置');
      this.win.hide();
      this.win.next_button.hide();
      this.win.addOption("X", this.complateSet, "X");
      this.win.addOption("C", this.complateSet, "C");
      this.win.addOption("A", this.complateSet, "A");
      this.win.addOption("S", this.complateSet, "S");
      this.win.addOption("D", this.complateSet, "D");
      this.win.addOption("F", this.complateSet, "F");
      this.ui = new Sprite("/images/ui/hotkey.png");
    }

    HotkeyManager.prototype.set = function() {
      var that;
      that = game.role.hotkey_manager;
      that.win.next_button.hide();
      that["catch"] = this;
      return that.win.show();
    };

    HotkeyManager.prototype.complateSet = function() {
      var that;
      that = game.role.hotkey_manager;
      that.data[this[0]] = that["catch"][0];
      return that.win.hide();
    };

    HotkeyManager.prototype.use = function(key) {
      var item, k, skill, _i, _j, _len, _len1, _ref, _ref1;
      if (!this.data[key]) {
        return;
      }
      if (this.data[key].constructor.name === 'skill') {
        _ref = game.role.skills;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          skill = _ref[_i];
          if (skill[0] === this.data[key]) {
            skill[0].use(game.role, skill[1]);
          }
        }
      } else if (this.data[key] instanceof window.Props) {
        _ref1 = game.role.item_manager.items;
        for (k = _j = 0, _len1 = _ref1.length; _j < _len1; k = ++_j) {
          item = _ref1[k];
          if (item.item === this.data[key]) {
            if (game.role.item_manager.items[k].amount) {
              game.role.item_manager.items[k].amount--;
              item.item.use();
              game.role.item_manager.reviewItems();
            }
          }
        }
      }
    };

    HotkeyManager.prototype.redraw = function() {
      var amount, context, hotkey, hotkey_x, i, item, k, key, _i, _j, _len, _len1, _ref, _results;
      context = game.canvas.context;
      this.ui.drawUI(500, 0);
      hotkey = ["X", "C", "A", "S", "D", "F"];
      hotkey_x = [505, 549, 593, 637, 681, 726];
      context.font = "16px Arial";
      _results = [];
      for (i = _i = 0, _len = hotkey.length; _i < _len; i = ++_i) {
        key = hotkey[i];
        context.fillStyle = "#000";
        context.fillText(key, hotkey_x[i] + 16, 41);
        context.fillStyle = "#FFF";
        context.fillText(key, hotkey_x[i] + 15, 40);
        if (this.data[key] != null) {
          this.data[key].sprite.drawUI(hotkey_x[i], 5, 40, 40);
        }
        if (this.data[key] instanceof window.Props) {
          amount = 0;
          _ref = game.role.item_manager.items;
          for (k = _j = 0, _len1 = _ref.length; _j < _len1; k = ++_j) {
            item = _ref[k];
            if (item.item === this.data[key]) {
              if (game.role.item_manager.items[k].amount) {
                amount = game.role.item_manager.items[k].amount;
              }
            }
          }
          context.fillStyle = "#000";
          context.fillText(amount, hotkey_x[i] + 16, 41);
          context.fillStyle = "#FFF";
          _results.push(context.fillText(amount, hotkey_x[i] + 15, 40));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return HotkeyManager;

  })();

  window.SkillManager = (function() {
    function SkillManager() {
      this.win = new Windows(350, 400, '技能視窗');
      this.win.hide();
    }

    SkillManager.prototype.show = function() {
      if (this.win.isHide()) {
        this.win.show();
        return this.redraw();
      } else {
        return this.win.hide();
      }
    };

    SkillManager.prototype.redraw = function() {
      var block, skill, _i, _len, _ref;
      this.win.setMsg("");
      _ref = game.role.skills;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        skill = _ref[_i];
        if (game.role.skillpoint) {
          block = new SkillBlock("/images/icon/add.png", skill[0].name, skill[0].description, skill[1], skill[0].maxLV);
          block.addEvent("dblclick", game.role.skillup, skill);
        } else {
          block = new SkillBlock(skill[0].icon, skill[0].name, skill[0].description, skill[1], skill[0].maxLV);
          block.addEvent("dblclick", game.role.hotkey_manager.set, skill);
        }
        block.appendTo(this.win.main);
      }
      block = new Block('技能點數 : ' + game.role.skillpoint);
      block.addClass("skillpoint");
      return block.appendTo(this.win.main);
    };

    return SkillManager;

  })();

  window.skill = (function(_super) {
    __extends(skill, _super);

    function skill(option) {
      var k, v;
      this.sprite = new Sprite(option.icon);
      for (k in option) {
        v = option[k];
        this[k] = v;
      }
    }

    skill.prototype.start = function(self, lv) {};

    skill.prototype.use = function(self, lv) {
      if (self.skillCD[this.id] > new Date().getTime()) {
        return;
      }
      if (self.mp < this.mp) {
        return;
      }
      this.start(self, lv);
      self.mp -= this.mp;
      self.skillCD[this.id] = new Date().getTime() + this.cd;
      self.useSkill();
      if (this.rangeType === "front") {
        this.skillDamageTimer = 0;
        this.damageInterval = this.interval(this._damageFront, this.speed, self, self.dir, lv);
        return this.timeout(this.clear, this.speed * (this.range + 1));
      } else if (this.rangeType === "selfAround") {
        this.skillDamageTimer = 0;
        game.skill.s003.use(game.role, 10);
        this.damageInterval = this.interval(this._damageAround, this.speed, self, self.dir, lv);
        return this.timeout(this.clear, this.speed * (this.range + 1));
      }
    };

    skill.prototype.clear = function() {
      return clearInterval(this.damageInterval);
    };

    skill.prototype._damageFront = function(self, dir, lv) {
      var monster, sign;
      this.skillDamageTimer++;
      sign = dir2sign(dir);
      monster = self.map.findMonster(self.position[0] + sign[0] * this.skillDamageTimer, self.position[1] + sign[1] * this.skillDamageTimer);
      if (monster) {
        return this.damage(self, lv, [monster]);
      }
    };

    skill.prototype._damageAround = function(self, dir, lv) {
      var monster, monsters, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      monsters = [];
      if (this.skillDamageTimer === 0) {
        monster = self.map.findMonster(self.position[0], self.position[1]);
        if (monster) {
          this.damage(self, lv, [monster]);
        }
      } else {
        for (x = _i = _ref = self.position[0] - this.skillDamageTimer, _ref1 = self.position[0] + this.skillDamageTimer; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
          monster = self.map.findMonster(x, self.position[1] - this.skillDamageTimer);
          if (monster) {
            monsters.push(monster);
          }
          monster = self.map.findMonster(x, self.position[1] + this.skillDamageTimer);
          if (monster) {
            monsters.push(monster);
          }
        }
        for (y = _j = _ref2 = self.position[1] - this.skillDamageTimer + 1, _ref3 = self.position[1] + this.skillDamageTimer - 1; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; y = _ref2 <= _ref3 ? ++_j : --_j) {
          monster = self.map.findMonster(self.position[0] - this.skillDamageTimer, y);
          if (monster) {
            monsters.push(monster);
          }
          monster = self.map.findMonster(self.position[0] + this.skillDamageTimer, y);
          if (monster) {
            monsters.push(monster);
          }
        }
        if (monsters.length > 0) {
          this.damage(self, lv, monsters);
        }
      }
      return this.skillDamageTimer++;
    };

    return skill;

  })(window.Base);

  game.skill = {};

  game.skill.s001 = new window.skill({
    id: 1,
    name: "狂擊",
    description: "將全身精氣纏繞於劍上, 發出奮力一擊",
    maxLV: 10,
    icon: "/images/icon/sm_bash.png",
    type: "active",
    target: "enemy",
    rangeType: "front",
    range: 2,
    mp: 10,
    cd: 1000,
    speed: 100,
    start: function(self, lv) {
      var sign;
      sign = dir2sign(self.dir);
      return game.effect.e003.show(self.map, self.position[0], self.position[1], self.dir);
    },
    damage: function(self, lv, targets) {
      var target, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        _results.push(target.damage(self, Math.ceil(self.atk * lv * (100 + random(-20, 20)) / 100)));
      }
      return _results;
    }
  });

  game.skill.s002 = new window.skill({
    id: 2,
    name: "加速術",
    description: "提身自身移動速度",
    maxLV: 10,
    icon: "/images/icon/al_incagi.png",
    type: "active",
    target: "self",
    rangeType: "self",
    range: 5,
    mp: 10,
    cd: 1000,
    speed: 10,
    start: function(self, lv) {
      game.effect.e001.show(self.map, self.position[0], self.position[1], self.dir);
      return game.status.s001.use(self, 10000 + lv * 1000, lv);
    }
  });

  game.skill.s003 = new window.skill({
    id: 3,
    name: "緩速速",
    description: "造成周圍的怪物移動速度減緩",
    maxLV: 1,
    icon: "/images/icon/al_decagi.png",
    type: "active",
    target: "enemy",
    rangeType: "selfAround",
    range: 3,
    mp: 10,
    cd: 1000,
    speed: 10,
    start: function(self, lv) {
      return game.effect.e011.show(self.map, self.position[0], self.position[1], 0);
    },
    damage: function(self, lv, targets) {
      var target, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        game.effect.e000.show(target.map, target.position[0], target.position[1], 0);
        _results.push(game.status.s005.use(target, 5000 + lv * 500));
      }
      return _results;
    }
  });

  game.skill.s004 = new window.skill({
    id: 4,
    name: "天使之障壁",
    description: "提升自身防禦力",
    maxLV: 10,
    icon: "/images/icon/al_angelus.png",
    type: "active",
    target: "self",
    rangType: "self",
    range: 0,
    mp: 10,
    start: function(self, lv) {
      game.effect.e002.show(self.map, self.position[0], self.position[1], 0);
      return game.status.s006.use(self, 10000 + lv * 1000, lv);
    }
  });

  game.skill.s005 = new window.skill({
    id: 5,
    name: "天使之賜福",
    description: "提升自身攻擊力/迴避率/命中率/血量",
    maxLV: 10,
    icon: "/images/icon/al_blessing.png",
    type: "active",
    target: "self",
    rangType: "self",
    range: 0,
    mp: 10,
    start: function(self, lv) {
      game.effect.e010.show(self.map, self.position[0], self.position[1], 0);
      return game.status.s007.use(self, 10000 + lv * 3000, lv);
    }
  });

  game.skill.s006 = new window.skill({
    id: 6,
    name: "反射盾",
    description: "受到攻擊時有機率將傷害反彈",
    maxLV: 10,
    icon: "/images/icon/cr_reflectshield.png",
    type: "active",
    target: "self",
    rangType: "self",
    range: 0,
    mp: 10,
    start: function(self, lv) {
      game.effect.e053.show(self.map, self.position[0], self.position[1], 0);
      return game.status.s008.use(self, 10000 + lv * 10000, lv);
    }
  });

}).call(this);
